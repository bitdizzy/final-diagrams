{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE FunctionalDependencies #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE TypeFamilies #-}
signature Diagrams.Final.Sig.Space
  ( module Diagrams.Final.Sig.Space
  ) where

import Control.Lens
import Data.Constraint
import Data.Functor.Product
import Linear (Additive, Metric)
import Linear.Affine (Affine(..))

data Scalar
instance Num Scalar
instance Floating Scalar
instance Fractional Scalar
instance Eq Scalar
instance Ord Scalar

data Vector :: * -> *
instance Functor Vector
instance Foldable Vector
instance Traversable Vector
instance Additive Vector
instance Metric Vector

basis :: forall n. Num n => [Vector n]

data Point :: * -> *
instance Affine Point
instance Functor Point

origin :: forall n. Num n => Point n

-- | 'Vector' should be the 'Diff' of 'Point'
vectorIsDiffPoint :: Dict (Diff Point ~ Vector)

class Diff p ~ v => IsDiffOf p v

instance IsDiffOf Point Vector

data LinearTransform :: * -> *
instance Functor LinearTransform
instance (Semigroup (LinearTransform a))
instance Monoid (LinearTransform a)

inverseLinear :: forall n. Num n => LinearTransform n -> LinearTransform n
adjoint :: forall n. Num n => LinearTransform n -> LinearTransform n
det :: forall n. Num n => LinearTransform n -> n

scalingBy :: forall n. Num n => n -> LinearTransform n

data AffineTransform :: * -> *
instance Functor AffineTransform
instance Semigroup (AffineTransform a)
instance Monoid (AffineTransform a)

inverseAffine :: forall n. Num n => AffineTransform n -> AffineTransform n
translateBy :: forall n. Num n => Vector n -> AffineTransform n

class LinearAction n a | a -> n where
  actL :: LinearTransform n -> a -> a

instance forall n. Num n => LinearAction n (Vector n)

class AffineAction n a | a -> n where
  actA :: AffineTransform n -> a -> a

instance forall n. Num n => AffineAction n (Point n)

class RelativeTo n a b | a -> n b where
  relativeTo :: Point n -> Iso' a b
  relativeToOrigin :: Iso' a b

instance forall n. Num n => RelativeTo n (AffineTransform n) (Product LinearTransform Vector n)
instance forall n. Num n => RelativeTo n (Point n) (Vector n)
